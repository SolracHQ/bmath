# Type System Tests
# ================
# Tests for type system, type checking, and type conversions

"Testing Type System..."

# [1] Basic Type Checking
"1. Basic Type Checking"
# Test type() function with different values
assert_eq(type(42), Int, "type(42) is Int", "✓ type(42) is Int")
assert_eq(type(3.14), Real, "type(3.14) is Real", "✓ type(3.14) is Real")
assert_eq(type(true), Bool, "type(true) is Bool", "✓ type(true) is Bool")
assert_eq(type([1, 2, 3]), Vec, "type([1,2,3]) is Vec", "✓ type([1,2,3]) is Vec")
assert_eq(type(|x| x + 1), Function, "type(lambda) is Function", "✓ type(lambda) is Function")

# Test complex numbers
complexNum = 3 + 4i
assert_eq(type(complexNum), Complex, "type(3+4i) is Complex", "✓ type(3+4i) is Complex")

pureImaginary = 5i
assert_eq(type(pureImaginary), Complex, "type(5i) is Complex", "✓ type(5i) is Complex")

"✓ Basic type checking tests passed"

# [2] Type Comparisons and Identity
"2. Type Comparisons"
# Test type equality
assert_eq(type(5) == Int, true, "Type equality comparison")
assert_eq(type(5.0) == Real, true, "Float type comparison")
assert_eq(type(5i) == Real, false, "Different type comparison")

# Test 'is' operator for type checking
assert_eq(5 is Int, true, "Value 'is' type check")
assert_eq(5.0 is Real, true, "Float 'is' type check")
assert_eq(5i is Real, false, "Wrong type 'is' check")

"✓ Type comparison tests passed"

# [3] Type Conversion - Arrow Operator
"3. Type Conversion - Arrow Operator"
# Integer to real
intToReal = 42 -> Real
assert_eq(intToReal, 42.0, "Integer to real conversion")
assert_eq(type(intToReal), Real, "Converted value has real type")

# Real to integer (truncation)
realToInt = 3.14 -> Int
assert_eq(realToInt, 3, "Real to Int conversion")
assert_eq(type(realToInt), Int, "Converted value has Int type")

# Boolean conversions
assert_error(|| true -> integer, "Boolean to integer conversion should fail", "✓ Boolean to integer conversion fail")

"✓ Arrow operator conversion tests passed"

# [4] Type Conversion - Function Style
"4. Type Conversion - Function Style"
# Same conversions using function syntax
intToReal2 = Real(42)
assert_eq(intToReal2, 42.0, "Function-style Int to Real")
assert_eq(type(intToReal2), Real, "Function-style converted type")

realToInt2 = Int(3.14)
assert_eq(realToInt2, 3, "Function-style Real to Int")

"✓ Function-style conversion tests passed"

# [5] Vector and Sequence Type Conversions
"5. Vector and Sequence Type Conversions"
# Vector to sequence
testVector = [1, 2, 3, 4, 5]
vectorToSeq = testVector -> Seq
assert_eq(type(vectorToSeq), Seq, "Vector to Seq conversion")

# We can test that it works by collecting it back
seqToVector = vectorToSeq -> collect
assert_eq(seqToVector, [1, 2, 3, 4, 5], "Sequence back to vector")

# Sequence to vector (using collect)
testSeq = seq(3, |i| i + 1)
seqCollected = testSeq -> collect
assert_eq(seqCollected, [1, 2, 3], "Sequence collected to vector")
assert_eq(type(seqCollected), Vec, "Collected sequence is Vec")

"✓ Vector/sequence conversion tests passed"

# [6] Complex Type Conversions
"6. Complex Type Conversions"
# Real to complex

"6. Complex Type Conversions (skipped)"
# These tests are skipped due to optimization: numbers with 0 imaginary part are downcasted.
assert_eq(true, true, "SKIPPED: Real to complex conversion (downcasted)")
assert_eq(true, true, "SKIPPED: Integer to complex conversion (downcasted)")
"✓ Complex type conversion tests skipped"

# [7] Composite Types
"7. Composite Types"
# Test union types (number = integer | real | complex)
assert_eq(5 is Number, true, "Integer is Number")
assert_eq(3.14 is Number, true, "Real is Number")
assert_eq(2+3i is Number, true, "Complex is Number")
assert_eq(true is Number, false, "Bool is not Number")

# Test any type
assert_eq(5 is Any, true, "Integer is Any")
assert_eq(true is Any, true, "Bool is Any")
assert_eq([1,2] is Any, true, "Vec is Any")
assert_eq((|x| x) is Any, true, "Function is Any")

"✓ Composite type tests passed"

# [8] Type Promotion in Operations
"8. Type Promotion in Operations"
# Test automatic type promotion in arithmetic
intPlusReal = 5 + 3.14
assert_eq(type(intPlusReal), Real, "int + Real promotes to Real")

realPlusComplex = 3.14 + 2i
assert_eq(type(realPlusComplex), Complex, "Real + Complex promotes to Complex")

intPlusComplex = 5 + 3i
assert_eq(type(intPlusComplex), Complex, "Int + Complex promotes to Complex")

"✓ Type promotion tests passed"

# [9] Type-specific Operations
"9. Type-specific Operations"
# Test operations that work only on specific types
numericVector = [1, 2, 3]
assert_eq(type(numericVector->sum), Int, "Vector sum type")

# Test vector operations
dotResult = [1, 2] -> dot([3, 4])
assert_eq(type(dotResult), Int, "Dot product result type")

"✓ Type-specific operation tests passed"

# [10] Error Cases
"10. Type System Error Cases"
# Test invalid conversions
assert_error(|| "hello" -> Int, "String to Int should fail")
assert_error(|| [1, 2] -> Int, "Vec to Int should fail")

# Test type operations on invalid types
assert_error(|| type(), "type() with no arguments should fail")


"✓ Type system error tests passed"

# [11] Function Type Testing
"11. Function Type Testing"
testFunc = |x, y| x + y
assert_eq(type(testFunc), Function, "Lambda has Function type")

# Test that functions are first-class
funcInVar = testFunc
assert_eq(type(funcInVar), Function, "Function stored in variable")
assert_eq(funcInVar(3, 4), 7, "Function variable invocation")

"✓ Function type tests passed"

"All type system tests completed!"
